/obj/item/mech_equipment/weapon
	name = "mecha weapon"
	var/projectile
	var/fire_sound
	var/projectiles_per_shot = 1
	var/variance = 0
	var/randomspread = FALSE //use random spread for machineguns, instead of shotgun scatter
	var/projectile_delay = 0
	var/firing_effect_type = /obj/effect/temp_visual/dir_setting/firing_effect	//the visual effect appearing when the weapon is fired.
	var/kickback = TRUE //Will using this weapon in no grav push mecha back.
	var/automatic = FALSE
	var/eject_casings = FALSE
	var/one_casing = FALSE
	var/casing_type

/obj/item/mech_equipment/weapon/proc/get_shot_amount()
	return projectiles_per_shot

/obj/item/mech_equipment/weapon/proc/action(atom/target, params)

	var/turf/curloc = get_turf(owner)
	var/turf/targloc = get_turf(target)
	if (!targloc || !istype(targloc) || !curloc)
		return 0
	if (targloc == curloc)
		return 0
	if(!action_checks(target))
		return
	var/eject_done = FALSE
	for(var/i=1 to get_shot_amount())
		var/obj/projectile/A = new projectile(curloc)
		A.firer = owner.pilots[1]
		A.original = target
		if(!A.suppressed && firing_effect_type)
			new firing_effect_type(get_turf(src), owner.dir)

		var/spread = 0
		if(variance)
			if(randomspread)
				spread = round((rand() - 0.5) * variance)
			else
				spread = round((i / projectiles_per_shot - 0.5) * variance)
		A.preparePixelProjectile(target, owner.pilots[1], params, spread)

		A.fire()
		playsound(owner, fire_sound, 50, TRUE)
		if(eject_casings && !eject_done)
			var/obj/item/ammo_casing/ejected = new casing_type(src)
			ejected.on_eject(owner)
			if(one_casing)
				eject_done = TRUE
		sleep(max(0, projectile_delay))

	if(kickback)
		owner.newtonian_move(turn(owner.dir,180))
	owner.log_message("Fired from [src.name], targeting [target].", LOG_MECHA)
	owner.handle_hud_icons()
	return 1

/obj/item/mech_equipment/proc/action_checks(atom/target)
	return 1
//Base energy weapon type
/obj/item/mech_equipment/weapon/energy
	name = "general energy weapon"
	firing_effect_type = /obj/effect/temp_visual/dir_setting/firing_effect/energy

/obj/item/mech_equipment/weapon/energy/get_shot_amount()
	return min(round(owner.get_cell()?.charge / active_power_use), projectiles_per_shot)

/obj/item/mech_equipment/weapon/energy/get_hardpoint_maptext()
	if (active_power_use <= 0)
		return "INF"
	return "[owner.body.cell.charge/active_power_use]"

/obj/item/mech_equipment/weapon/energy/get_hardpoint_status_value()
	return owner.body.cell.charge/active_power_use

//Base ballistic weapon type
/obj/item/mech_equipment/weapon/ballistic
	name = "general ballistic weapon"
	fire_sound = 'sound/weapons/gun/smg/shot.ogg'
	var/projectiles
	var/projectiles_max //maximum amount of projectiles that can be chambered.
	var/projectiles_cache //ammo to be loaded in, if possible.
	var/projectiles_cache_max
	var/projectile_energy_cost
	var/disabledreload //For weapons with no cache (like the rockets) which are reloaded by hand
	var/ammo_type
	casing_type = /obj/item/ammo_casing/spent
	eject_casings = TRUE

/obj/item/mech_equipment/weapon/ballistic/Initialize() //initial(projectiles) prevented me from making mech weapons start empty TODO: PORT ALL OF TG MECH IMPROVEMENTS
	. = ..()
	projectiles_max ||= projectiles

/obj/item/mech_equipment/weapon/ballistic/get_shot_amount()
	return min(projectiles, projectiles_per_shot)

/obj/item/mech_equipment/weapon/ballistic/action_checks(target)
	if(!..())
		return 0
	if(projectiles <= 0)
		return 0
	return 1
/*
/obj/item/mecha_parts/mecha_equipment/weapon/ballistic/get_equip_info()
	return "[..()] \[[src.projectiles][projectiles_cache_max &&!projectile_energy_cost?"/[projectiles_cache]":""]\][!disabledreload &&(src.projectiles < projectiles_max)?" - <a href='?src=[REF(src)];rearm=1'>Rearm</a>":null]"
*/
/obj/item/mech_equipment/weapon/ballistic/get_hardpoint_status_value()
	return (projectiles/projectiles_per_shot)/(projectiles_max/projectiles_per_shot)

/obj/item/mech_equipment/weapon/ballistic/get_hardpoint_maptext()
	return "[projectiles/projectiles_per_shot]/[projectiles_cache/projectiles_per_shot]"

/obj/item/mech_equipment/weapon/ballistic/rearm()
	if(projectiles < projectiles_max)
		var/projectiles_to_add = projectiles_max - projectiles

		if(projectile_energy_cost)
			while(owner.get_cell()?.charge >= projectile_energy_cost && projectiles_to_add)
				projectiles++
				projectiles_to_add--
				owner.get_cell()?.charge -=projectile_energy_cost

		else
			if(!projectiles_cache)
				return FALSE
			if(projectiles_to_add <= projectiles_cache)
				projectiles = projectiles + projectiles_to_add
				projectiles_cache = projectiles_cache - projectiles_to_add
			else
				projectiles = projectiles + projectiles_cache
				projectiles_cache = 0

		log_message("Rearmed [src.name].", LOG_MECHA)
		return TRUE

/*
/obj/item/mecha_parts/mecha_equipment/weapon/ballistic/needs_rearm()
	. = !(projectiles > 0)
*/
/obj/item/mech_equipment/weapon/ballistic/attack_self(mob/user)
	. = ..()
	rearm()
/obj/item/mech_equipment/weapon/ballistic/action(atom/target)
	if(..())
		projectiles -= get_shot_amount()
		return 1

/obj/item/ammo_casing/spent/mecha
	name = "bullet casing"
	desc = "A bullet casing designed to fired from exosuit mounted weapons."
	projectile_type = null
	icon_state = "rifle-brass"
	transform = matrix(1.3, 0, 0, 0, 1.3, 0)
