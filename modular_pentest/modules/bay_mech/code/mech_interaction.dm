/mob/living/MouseDrop(atom/over)
	if(usr == src && usr != over)
		if(istype(over, /mob/living/exosuit))
			var/mob/living/exosuit/exosuit = over
			if(exosuit.enter(src))
				return
	return ..()

/mob/living/exosuit/proc/click_action(atom/A,mob/user,params)

	if(!user || incapacitated() || user.incapacitated())
		return

	if(!loc) return
	var/adj = A.Adjacent(src)

	var/modifiers = params2list(params)
	if(modifiers["shift"])
		examinate(user, A)
		return

	if(modifiers["ctrl"])
		if(selected_system)
			if(selected_system == A)
				selected_system.CtrlClick(user)
				user.changeNext_move(3)
				handle_hud_icons()
			return

	if(!(user in pilots) && user != src)
		return

	// Are we facing the target?
	if(A.loc != src && !(get_dir(src, A) & dir))
		return

	if(!arms)
		to_chat(user, span_warning("\The [src] has no manipulators!"))
		user.changeNext_move(3)
		return

	if(!arms.motivator || !arms.motivator.is_functional())
		to_chat(user, span_warning("Your motivators are damaged! You can't use your manipulators!"))
		user.changeNext_move(15)
		return

	// User is not necessarily the exosuit, or the same person, so update intent.
	if(user != src)
		a_intent = user.a_intent
		if(user.zone_selected)
			zone_selected= user.zone_selected
		else
			zone_selected = BODY_ZONE_CHEST
	// You may attack the target with your exosuit FIST if you're malfunctioning.
	var/failed = FALSE
	if(emp_damage > EMP_ATTACK_DISRUPT && prob(emp_damage*2))
		to_chat(user, span_danger("The wiring sparks as you attempt to control the exosuit!"))
		failed = TRUE

	if(!failed)
		if(selected_system)
			if(selected_system.on_cooldown)
				return
			if(selected_system == A)
				selected_system.attack_self(user)
				handle_hud_icons()
				return

			// Mounted non-exosuit systems have some hacky loc juggling
			// to make sure that they work.
			var/system_moved = FALSE
			var/obj/item/temp_system
			var/obj/item/mech_equipment/ME
			if(istype(selected_system, /obj/item/mech_equipment))
				ME = selected_system
				temp_system = ME.get_effective_obj()
				if(ME.mounted_location)
					switch(ME.mounted_location)
						if(HARDPOINT_LEFT_HAND, HARDPOINT_RIGHT_HAND)
							if(arms.damage_state >= MECH_COMPONENT_DAMAGE_DAMAGED_TOTAL)
								to_chat(user, span_warning("The [arms.name] are too damaged to be used!"))
								return
						if(HARDPOINT_HEAD)
							if(head.damage_state >= MECH_COMPONENT_DAMAGE_DAMAGED_TOTAL)
								to_chat(user, span_warning("The [head.name] are too damaged to be used!"))
								return
						if(HARDPOINT_LEFT_SHOULDER, HARDPOINT_RIGHT_SHOULDER)
							if(body.damage_state >= MECH_COMPONENT_DAMAGE_DAMAGED_TOTAL)
								to_chat(user, span_warning("The [body.name] are too damaged to be used!"))
								return
				if(temp_system in ME)
					system_moved = 1
					temp_system.forceMove(src)
			else
				temp_system = selected_system

			// Slip up and attack yourself maybe.
			failed = FALSE
			if(emp_damage>EMP_MOVE_DISRUPT && prob(10))
				failed = TRUE

			if(failed)
				var/list/other_atoms = orange(1, A)
				A = null
				while(LAZYLEN(other_atoms))
					var/atom/picked = pick_n_take(other_atoms)
					if(istype(picked))
						A = picked
						break
				if(!A)
					A = src
				adj = A.Adjacent(src)

			var/resolved

			if(adj) resolved = temp_system.melee_attack_chain(src, A, params)

			if(istype(temp_system, /obj/item/mech_equipment/weapon))
				var/obj/item/mech_equipment/weapon/system = ME
				system.action(A, params)

				resolved = TRUE
			if(!resolved && A && temp_system)
				var/mob/ruser = src
				if(!system_moved) //It's more useful to pass along clicker pilot when logic is fully mechside
					ruser = user
				temp_system.afterattack(A,ruser,adj,params)
			if(system_moved)
				temp_system.forceMove(selected_system)
			return

	if(A == src)
		//user.changeNext_move(2)
	else if(adj && user.a_intent == INTENT_HARM) //Prevents accidental slams.
		if(!get_cell()?.use(arms.power_use))
			to_chat(user, power == MECH_POWER_ON ? span_warning("Error: Power levels insufficient.") :  span_warning("\The [src] is powered off."))
			return
		user.changeNext_move(arms ? arms.action_delay : 7) // You've already commited to applying fist, don't turn and back out now!
		A.cusmech_melee_attack(src)
		playsound(src.loc, arms.punch_sound, 50, 1)
		handle_hud_icons()
	return

/mob/living/exosuit/proc/set_hardpoint(hardpoint_tag)
	clear_selected_hardpoint()
	if(hardpoints[hardpoint_tag])
		// Set the new system.
		selected_system = hardpoints[hardpoint_tag]
		selected_hardpoint = hardpoint_tag
		autofire_check(selected_system)
		return 1 // The element calling this proc will set its own icon.
	return 0

/mob/living/exosuit/proc/clear_selected_hardpoint()
	if(selected_hardpoint)
		if(selected_system.mounted_location)
			switch(selected_system.mounted_location)
				if(HARDPOINT_LEFT_HAND, HARDPOINT_RIGHT_HAND)
					if(arms.swap_speed)
						swapping_weapon = TRUE
						to_chat(pilots[1], span_warning("It will take [arms.swap_speed/10] seconds to swap out of selected system"))
						if(!do_after(pilots[1], arms.swap_speed, src, timed_action_flags = (IGNORE_USER_LOC_CHANGE|IGNORE_TARGET_LOC_CHANGE|IGNORE_HELD_ITEM)))
							swapping_weapon = FALSE
							return
				if(HARDPOINT_HEAD)
					if(head.swap_speed)
						swapping_weapon = TRUE
						to_chat(pilots[1], span_warning("It will take [head.swap_speed/10] seconds to swap out of selected system"))
						if(!do_after(pilots[1], head.swap_speed, src, timed_action_flags = (IGNORE_USER_LOC_CHANGE|IGNORE_TARGET_LOC_CHANGE|IGNORE_HELD_ITEM)))
							swapping_weapon = FALSE
							return
				if(HARDPOINT_LEFT_SHOULDER, HARDPOINT_RIGHT_SHOULDER)
					if(body.swap_speed)
						swapping_weapon = TRUE
						to_chat(pilots[1], span_warning("It will take [body.swap_speed/10] seconds to swap out of selected system"))
						if(!do_after(pilots[1], body.swap_speed, src, timed_action_flags = (IGNORE_USER_LOC_CHANGE|IGNORE_TARGET_LOC_CHANGE|IGNORE_HELD_ITEM)))
							swapping_weapon = FALSE
							return
				if(HARDPOINT_BACK)
					if(body.spinal_delay)
						swapping_weapon = TRUE
						to_chat(pilots[1], span_warning("It will take [body.spinal_delay/10] seconds to swap out of selected system"))
						if(!do_after(pilots[1], body.spinal_delay, src, timed_action_flags = (IGNORE_USER_LOC_CHANGE|IGNORE_TARGET_LOC_CHANGE|IGNORE_HELD_ITEM)))
							swapping_weapon = FALSE
							return
		swapping_weapon = FALSE
		for(var/hardpoint in hardpoints)
			if(hardpoint != selected_hardpoint)
				continue
			var/obj/screen/exosuit/hardpoint/H = hardpoint_hud_elements[hardpoint]
			if(istype(H))
				H.icon_state = "hardpoint"
				break
		selected_system = null
	selected_hardpoint = null

/mob/living/exosuit/proc/check_enter(mob/user, silent = FALSE, check_incap = TRUE)
	if(!user || (check_incap && user.incapacitated()))
		return FALSE
	if (user.buckled)
		if (!silent)
			to_chat(user, span_warning("You are currently buckled to \the [user.buckled]."))
		return FALSE
	if(!user.Adjacent(src))
		return FALSE
	if(hatch_locked)
		if(!silent)
			to_chat(user, span_warning("The [body.hatch_descriptor] is locked."))
		return FALSE
	if(hatch_closed)
		if(!silent)
			to_chat(user, span_warning("The [body.hatch_descriptor] is closed."))
		return FALSE
	if(LAZYLEN(pilots) >= LAZYLEN(body.pilot_positions))
		if(!silent)
			to_chat(user, span_warning("\The [src] is occupied to capacity."))
		return FALSE
	return TRUE

/mob/living/exosuit/proc/enter(mob/user, silent = FALSE, check_incap = TRUE, instant = FALSE)
	if(!check_enter(user, silent, check_incap))
		return FALSE
	to_chat(user, span_notice("You start climbing into \the [src]..."))
	if(!body)
		return FALSE
	if(!instant && !do_after(user, body.climb_time, src))
		return FALSE
	if(!check_enter(user, silent, check_incap))
		return FALSE
	if(!silent)
		to_chat(user, span_notice("You climb into \the [src]."))
		//playsound(src, 'sound/machines/airlock_heavy.ogg', 60, 1)
	add_pilot(user)
	return TRUE

/// Adds a mob to the pilots list and destroyed event handlers.
/mob/living/exosuit/proc/add_pilot(mob/user)
	if (LAZYISIN(pilots, user))
		return
	user.forceMove(src)
	//user.PushClickHandler(/datum/click_handler/default/mech)
	if (user.client)
		user.client.screen |= hud_elements
	LAZYADD(pilots, user)
	RegisterSignal(user, COMSIG_MOB_UPDATE_SIGHT, PROC_REF(update_user_sight))
	//LAZYDISTINCTADD(user.additional_vision_handlers, src)
	sync_access()
	update_pilots()
	SEND_SIGNAL(src,COMSIG_MECH_ENTERED, user)
	autofire_check()
	handle_hud_icons()

/// Removes a mob from the pilots list and destroyed event handlers. Called by the destroyed event.
/mob/living/exosuit/proc/remove_pilot(mob/user)
	if (!LAZYISIN(pilots, user))
		return
	//user.RemoveClickHandler(/datum/click_handler/default/mech)
	if (!QDELETED(user))
		user.forceMove(loc)
	if (user.client)
		user.client.screen -= hud_elements
		user.client.eye = user
	//LAZYREMOVE(user.additional_vision_handlers, src)
	LAZYREMOVE(pilots, user)
	UnregisterSignal(user, COMSIG_MOB_UPDATE_SIGHT)
	user.update_sight()
	sync_access()
	update_pilots()
	SEND_SIGNAL(src,COMSIG_MECH_EXITED,user)

/mob/living/exosuit/proc/sync_access()
	access_card.access = saved_access.Copy()
	//if(sync_access)
		//for(var/mob/carbon/pilot in pilots)
			//access_card.access = pilot.wear_id
			//to_chat(pilot, span_notice("Security access permissions synchronized."))

/mob/living/exosuit/proc/eject(mob/user, silent)
	if(!user || !(user in src.contents))
		return
	if(hatch_closed)
		if(hatch_locked)
			if(!silent)
				to_chat(user, span_warning("The [body.hatch_descriptor] is locked."))
			return
		hud_open.toggled()
		if(!silent)
			to_chat(user, span_notice("You open the hatch and climb out of \the [src]."))
	else
		if(!silent)
			to_chat(user, span_notice("You climb out of \the [src]."))
	var/mob/living/carbon/human/pilot = user
	remove_pilot(user)
	pilot.cure_blind("blind_[REF(src)]")
	return 1


/mob/living/exosuit/attackby(obj/item/tool, mob/user, list/click_params)
	// Cable Coil - Repair burn damage
	if (isCoil(tool))
		if (!getFireLoss())
			USE_FEEDBACK_FAILURE("\The [src] has no electrical damage to repair.")
			return TRUE
		var/list/damaged_parts = list()
		for (var/obj/item/mech_component/component in list(arms, legs, body, head))
			if (component?.burn_damage)
				damaged_parts += component
		var/obj/item/mech_component/input_fix = input(user, "Which component would you like to fix?", "\The [src] - Fix Component") as null|anything in damaged_parts
		if (!input_fix)
			return TRUE
		if (!input_fix.burn_damage)
			USE_FEEDBACK_FAILURE("\The [src]'s [input_fix.name] no longer needs repair.")
			return TRUE
		input_fix.repair_burn_generic(tool, user)
		return TRUE
	if(istype(tool, /obj/item/mecha_ammo))
		ammo_resupply(tool, user)
		return
	// Crowbar - Force open locked cockpit
	if (isCrowbar(tool))
		if (!body)
			USE_FEEDBACK_FAILURE("\The [src] has no cockpit to force.")
			return TRUE
		if (!hatch_locked)
			USE_FEEDBACK_FAILURE("\The [src]'s cockpit isn't locked. You don't need to force it.")
			return TRUE
		user.visible_message(
			span_warning("\The [user] starts forcing \the [src]'s emergency [body.hatch_descriptor] release using \a [tool]."),
			span_warning("You start forcing \the [src]'s emergency [body.hatch_descriptor] release using \the [tool].")
		)
		if (!do_after(user, 3 SECONDS, src))
			return TRUE
		if (!body)
			USE_FEEDBACK_FAILURE("\The [src] has no cockpit to force.")
			return TRUE
		//playsound(src, 'sound/machines/bolts_up.ogg', 25, TRUE)
		hatch_locked = FALSE
		hatch_closed = FALSE
		for (var/mob/pilot in pilots)
			eject(pilot, TRUE)
		hud_open.update_icon()
		update_icon()
		user.visible_message(
			span_warning("\The [user] forces \the [src]'s emergency [body.hatch_descriptor] release using \a [tool]."),
			span_warning("You force \the [src]'s emergency [body.hatch_descriptor] release using \the [tool].")
		)
		return TRUE

	// Exosuit Customization Kit - Customize the exosuit
	if (istype(tool, /obj/item/toy/crayon/spraycan))
		var/obj/item/toy/crayon/spraycan/paint = tool
		var/input = input(user, "Where would you like to paint \the [name]?", "\The [src] - Paint selection") as null|anything in list(arms, legs, head, body)
		var/obj/item/mech_component/component = input
		component.set_color(paint.paint_color)
		update_icon()
		user.visible_message(
			span_notice("\The [user] opens \the [tool] and spends some quality time customising \the [src]."),
			span_notice("You open \the [tool] and spend some quality time customising \the [src].")
		)
		return TRUE

	// Mech Equipment - Install equipment
	if (istype(tool, /obj/item/mech_equipment))
		if (hardpoints_locked)
			USE_FEEDBACK_FAILURE("\The [src]'s hardpoint system is locked.")
			return TRUE
		var/obj/item/mech_equipment/mech_equipment = tool
		if (mech_equipment.owner)
			USE_FEEDBACK_FAILURE("\The [tool] is already owned by \the [mech_equipment.owner]. This might be a bug.")
			return TRUE
		var/free_hardpoints = list()
		for (var/hardpoint in hardpoints)
			if (isnull(hardpoints[hardpoint]) && (!length(mech_equipment.restricted_hardpoints) || (hardpoint in mech_equipment.restricted_hardpoints)))
				free_hardpoints += hardpoint
		if (!length(free_hardpoints))
			USE_FEEDBACK_FAILURE("\The [src] has no free hardpoints for \the [tool].")
			return TRUE
		var/input = input(user, "Where would you like to install \the [tool]?", "\The [src] - Hardpoint Installation") as null|anything in free_hardpoints
		if (!input)
			return TRUE
		if (hardpoints[input] != null)
			USE_FEEDBACK_FAILURE("\The [input] slot on \the [src] is no longer free. It has \a [hardpoints[input]] attached.")
			return TRUE
		install_system(tool, input, user)
		return TRUE

	// Multitool - Remove component
	if (isMultitool(tool))
		if (hardpoints_locked)
			USE_FEEDBACK_FAILURE("\The [src]'s hardpoint system is locked.")
			return TRUE
		var/list/parts = list()
		for (var/hardpoint in hardpoints)
			if (hardpoints[hardpoint])
				parts += hardpoint
		var/input = input(user, "Which component would you like to remove?", "\The [src] - Remove Hardpoint") as null|anything in parts
		if (!input)
			return TRUE
		if (isnull(hardpoints[input]))
			USE_FEEDBACK_FAILURE("\The [src] not longer has a component in the [input] slot.")
			return TRUE
		remove_system(input, user)
		return TRUE

	// Power Cell - Install cell
	if (istype(tool, /obj/item/stock_parts/cell))
		if (!maintenance_protocols)
			USE_FEEDBACK_FAILURE("\The [src]'s maintenance protocols must be enabled to install \the [tool].")
			return TRUE
		if (body?.cell)
			USE_FEEDBACK_FAILURE("\The [src] already has \a [body.cell] installed.")
			return TRUE
		if (!user.transferItemToLoc(tool, body))
			FEEDBACK_UNEQUIP_FAILURE(user, tool)
			return TRUE
		body.cell = tool
		playsound(src, 'sound/items/Screwdriver.ogg', 50, TRUE)
		user.visible_message(
			span_notice("\The [user] installs \a [tool] into \the [src]."),
			span_notice("You install \the [tool] into \the [src].")
		)
		return TRUE

	// Screwdriver - Remove cell
	if (isScrewdriver(tool))
		if (!maintenance_protocols)
			USE_FEEDBACK_FAILURE("\The [src]'s maintenance protocols must be enabled to access the power cell.")
			return TRUE
		if (!body?.cell)
			USE_FEEDBACK_FAILURE("\The [src] has no power cell to remove.")
			return TRUE
		user.visible_message(
			span_notice("\The [user] starts removing \the [src]'s power cell with \a [tool]."),
			span_notice("You start removing \the [src]'s power cell with \the [tool].")
		)
		if (!do_after(user, 3 SECONDS, src))
			return
		if (!maintenance_protocols)
			USE_FEEDBACK_FAILURE("\The [src]'s maintenance protocols must be enabled to access the power cell.")
			return TRUE
		if (!body?.cell)
			USE_FEEDBACK_FAILURE("\The [src] has no power cell to remove.")
			return TRUE
		user.put_in_hands(body.cell)
		power = MECH_POWER_OFF
		hud_power_control.update_icon()
		body.cell = null
		user.visible_message(
			span_notice("\The [user] removes \the [src]'s power cell with \a [tool]."),
			span_notice("You remove \the [src]'s power cell with \the [tool].")
		)
		return TRUE

	// Welding Tool - Repair physical damage
	if (isWelder(tool))
		if (!getBruteLoss())
			USE_FEEDBACK_FAILURE("\The [src] has no physical damage to repair.")
			return TRUE
		var/list/damaged_parts = list()
		for (var/obj/item/mech_component/component in list(arms, legs, body, head))
			if (component?.brute_damage)
				damaged_parts += component
		var/obj/item/mech_component/input_fix = input(user, "Which component would you like to fix?", "\The [src] - Fix Component") as null|anything in damaged_parts
		if (!input_fix)
			return TRUE
		if (!input_fix.brute_damage)
			USE_FEEDBACK_FAILURE("\The [src]'s [input_fix.name] no longer needs repair.")
			return TRUE
		input_fix.repair_brute_generic(tool, user)
		return TRUE

	// Wrench - Toggle securing bolts
	if (isWrench(tool))
		if (!maintenance_protocols)
			USE_FEEDBACK_FAILURE("\The [src]'s maintenance protocols must be enabled to access the securing bolts.")
			return TRUE
		user.visible_message(
			span_notice("\The [user] starts removing \the [src]'s securing bolts with \a [tool]."),
			span_notice("You start removing \the [src]'s securing bolts with \the [tool].")
		)
		if (!do_after(user, 6 SECONDS, src))
			return TRUE
		if (!maintenance_protocols)
			USE_FEEDBACK_FAILURE("\The [src]'s maintenance protocols must be enabled to access the securing bolts.")
			return TRUE
		user.visible_message(
			span_notice("\The [user] removes \the [src]'s securing bolts with \a [tool], dismantling it."),
			span_notice("You remove \the [src]'s securing bolts with \the [tool], dismantling it.")
		)
		dismantle()
		return TRUE

	return ..()
/*

/mob/living/exosuit/attack_hand(mob/user)
	// Drag the pilot out if possible.
	if(user.a_intent == INTENT_HARM)
		if(!LAZYLEN(pilots))
			to_chat(user, span_warning("There is nobody inside \the [src]."))
		else if(!hatch_closed)
			var/mob/pilot = pick(pilots)
			user.visible_message(span_danger("\The [user] is trying to pull \the [pilot] out of \the [src]!"))
			if(do_after(user, 3 SECONDS, src) && user.Adjacent(src) && (pilot in pilots) && !hatch_closed)
				user.visible_message(span_danger("\The [user] drags \the [pilot] out of \the [src]!"))
				eject(pilot, silent=1)
		else if(hatch_closed)
			if(MUTATION_FERAL in user.mutations)
				attack_generic(user, 5, "slams")
				user.user.changeNext_move(DEFAULT_ATTACK_COOLDOWN*2)
		return

	// Otherwise toggle the hatch.
	if(hud_open)
		hud_open.toggled()
	return

/mob/living/exosuit/attack_generic(mob/user, damage, attack_message = "smashes into")
	..()
	if(damage)
		playsound(loc, body.damage_sound, 40, 1)

/mob/living/exosuit/proc/attack_self(mob/user)
	return visible_message("\The [src] pokes itself.")
*/
/mob/living/exosuit/proc/rename(mob/user)
	if(user != src && !(user in pilots))
		return
	var/new_name = sanitize(input("Enter a new exosuit designation.", "Exosuit Name") as text|null)
	if(!new_name || new_name == name || (user != src && !(user in pilots)))
		return
	src.name = new_name
	to_chat(user, span_notice("You have redesignated this exosuit as \the [name]."))
/*
/mob/living/exosuit/get_inventory_slot(obj/item/I)
	for(var/h in hardpoints)
		if(hardpoints[h] == I)
			return h
	return 0
*/


/mob/living/exosuit/proc/ammo_resupply(obj/item/mecha_ammo/A, mob/user,fail_chat_override = FALSE)
	if(!A.rounds)
		if(!fail_chat_override)
			to_chat(user, "<span class='warning'>This box of ammo is empty!</span>")
		return FALSE
	var/ammo_needed
	var/found_gun
	for(var/hardpoint in hardpoints)
		if(istype(hardpoints[hardpoint], /obj/item/mech_equipment/weapon/ballistic))
			var/obj/item/mech_equipment/weapon/ballistic/gun = hardpoints[hardpoint]
			ammo_needed = 0

			if(istype(gun, /obj/item/mech_equipment/weapon/ballistic) && gun.ammo_type == A.ammo_type)
				found_gun = TRUE
				if(A.direct_load)
					ammo_needed = gun.projectiles_max - gun.projectiles
				else
					ammo_needed = gun.projectiles_cache_max - gun.projectiles_cache

				if(ammo_needed)
					if(ammo_needed < A.rounds)
						if(A.direct_load)
							gun.projectiles = gun.projectiles + ammo_needed
						else
							gun.projectiles_cache = gun.projectiles_cache + ammo_needed
						playsound(get_turf(user),A.load_audio,50,TRUE)
						to_chat(user, "<span class='notice'>You add [ammo_needed] [A.round_term][ammo_needed > 1?"s":""] to the [gun.name]</span>")
						A.rounds = A.rounds - ammo_needed
						A.update_name()
						return TRUE

					else
						if(A.direct_load)
							gun.projectiles = gun.projectiles + A.rounds
						else
							gun.projectiles_cache = gun.projectiles_cache + A.rounds
						playsound(get_turf(user),A.load_audio,50,TRUE)
						to_chat(user, "<span class='notice'>You add [A.rounds] [A.round_term][A.rounds > 1?"s":""] to the [gun.name]</span>")
						A.rounds = 0
						A.update_name()
						return TRUE
	if(!fail_chat_override)
		if(found_gun)
			to_chat(user, "<span class='notice'>You can't fit any more ammo of this type!</span>")
		else
			to_chat(user, "<span class='notice'>None of the equipment on this exosuit can use this ammo!</span>")
	return FALSE
